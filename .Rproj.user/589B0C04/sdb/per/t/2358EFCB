{
    "collab_server" : "",
    "contents" : "##### Discretization or Subsetting Functions ######\n\n#' Discretize a trajectory by temporal steps\n#' Note: this function is to be used if there are unequal steps between measurements. If the time step\n#' is uniform you should use subsetData as it is much faster\n#' @param track A trajectory data frame with the first column representing time.\n#' @param threshT The time step to use when discretizing.\n#'\n#' @return A subset of trajectory points with appropriate temporal discretization.\n#' @export\n#'\n#' @examples\ndiscretizeTemporally = function(track, threshT) {\n  track$keep = FALSE\n  lastTime = track[1,1]\n  track$keep[1] = T\n  for (thisFrame in 1:dim(track)[1]) {\n    if (track[thisFrame,1] >= lastTime + threshT) {\n      track$keep[thisFrame] = T\n      lastTime = track[thisFrame,1]\n\n    }\n  }\n  discrTrack = track[track$keep,]\n  discrTrack = discrTrack[,-ncol(discrTrack)]\n  return(discrTrack)\n}\n\n###FUNCTION###\n#INPUT:\n# track: a data frame that contains at least three columns (with the correct order required): Frame/Time, X position, Y position\n# threshL: The threshold length of discretization.\n#OUTPUT: discretizedTrack is a subset of the input track, with only the row entries selected such that the distance between consecutive positions in entry rows equals or exceeds the threshold limit.\ndiscretizeSpatially <- function(track,threshL) {\n  discretizedTrack <- track[1,]\n  initialPos <- track[1,2:3]\n  for (currFrame in 1:length(track[,1]))\n  {\n    #print(paste(\"Frame\",currFrame))\n    nextPos <- track[currFrame,2:3]\n    distance <- sqrt(sum((nextPos - initialPos)^2))\n    #print(distance)\n    if (distance > threshL)\n    {\n      #print(\"ADDED!\")\n      initialPos <- track[currFrame,2:3]\n      discretizedTrack <- rbind(discretizedTrack,track[currFrame,])\n    }\n  }\n  return(discretizedTrack)\n}\n\n\n#' Quick subset of data frames\n#' Quickly subset a data frame to every nth entry, where n is defined by nskip.\n#' @param dataFrame\n#' @param nskip\n#'\n#' @return\n#' @export\n#'\n#' @examples\nsubsetData = function(dataFrame, nskip) {\n  indsToKeep = seq(from = 1, to = nrow(dataFrame), by = nskip)\n  return(dataFrame[indsToKeep,])\n}\n\n\n##### Basic trajectory measurements #####\n\n####FUNCTION:\n#Receives a time series of x and y components of a vector. fromPrevious specifies if the function returns absolute angle\n#From (1,0) vector, or if you want the angle relative to the previous vector.\ngetAngles <- function(x,y,fromPrevious = FALSE)\n{\n  angles <- c(rep(0,length(x)))\n  #v <- normalize(x,y)\n\n  #print(length(angles))\n  if (!fromPrevious)\n  {\n    angles <-atan2(y,x)\n  }\n  else\n  {\n    baseAngle <- atan2(y[1],x[1])\n    for(i in 1:length(x))\n    {\n      newAngle <- atan2(y[i],x[i])\n      diff <- newAngle - baseAngle\n      if (is.na(diff)) { # If the difference is NA, then just assign NA.\n        angles[i] = newAngle\n      } else { # need to calculate the new angle\n\n        if (diff > pi) #Was some leftward-turn that went over the negative pi - pi line\n        {\n          diff <- (-2*pi+diff)\n        } else if(diff < -pi) # Rightward turn crossing the -pi pi line\n        {\n          diff <- 2*pi+diff\n        }\n        angles[i] <- diff\n      }\n\n      baseAngle <- newAngle\n    }\n    angles = c(angles[2:length(angles)],NA)\n  }\n  return(angles)\n}\n\n####FUNCTION: From a given input of time points and positions, it calculates the speeds\ncalculateSpeed = function(displacement)\n{\n  distance = sqrt(rowSums( displacement[,2:length(displacement[1,])]^2))\n  speed = distance/displacement[,1]\n  return(speed)\n}\n\n\n\n#' Measure point-by-point displacement in trajectory\n#' Measures\n#'\n#' @param movementData the original data frame of positions, discreized appropriately.\n#' @param colNames the names you wish to assign the columns for the displacements data frame.\n#'\n#' @return Returns a data frame with colNames column names with change in time and position.\n#' @export\n#'\n#' @examples\ncalculateDisplacement = function(movementData,colNames=c('deltaT','deltaX','deltaY','deltaZ')) {\n  numPoints = nrow(movementData)\n  dimensionality = ncol(movementData)\n  startingPoints = movementData[1:numPoints-1,]\n  endingPoints = movementData[2:numPoints,]\n  displacement = endingPoints - startingPoints\n  colnames(displacement) = colNames[1:dimensionality]\n  return(displacement)\n}\n\n\n\n#Calculates the displacements, speeds, absolute vector angles, and relative angles of movement data.\n#INPUT:\n#* movementData: a N-by-M dimensional vector containing, in each row, the time of recording and the coordinate values of the point at that time.\nderiveTrajectoryData = function(movementData) {\n  dim = length(movementData[1,])\n  displacement = calculateDisplacement(movementData)\n  absAngle = getAngles(displacement, fromPrevious = FALSE)\n  absAngle = c(absAngle,NA)\n  relAngle = getAngles(displacement, fromPrevious = TRUE)\n  relAngle = c(relAngle,NA)\n  displacement = rbind(displacement,c(rep(NA,length(displacement[1,]))))\n  speed = calculateSpeed(displacement)\n\n  movementData = cbind(movementData,displacement)\n  movementData$Speed = speed\n  movementData$AbsoluteAngle = absAngle\n  movementData$RelativeAngle = relAngle\n  return(movementData)\n}\n\n\n#' Calculate local tortuosity at any point in a trajectory\n#'\n#' @param trajectory A data frame containing the step-by-step displacements of a trajectory (dt, dX, dY)\n#' @param bufferSize The frame range over which to measure tortuosity.\n#'\n#' @return\n#' @export\n#'\n#' @examples\nmeasureTortuosity = function(trajectory,bufferSize)\n{\n  if (bufferSize < 1 | bufferSize > nrow(trajectory)/2)  {\n    print(\"Buffer size is invalid.\")\n    return\n  }\n  minIndex = bufferSize+1\n  maxIndex = nrow(trajectory)-bufferSize\n\n  tortuosity = c(rep(NA,length(trajectory[,1])))\n\n  steps = calculateDisplacement(trajectory)\n  colnames(steps) = c(\"deltaX\", \"deltaY\")\n  stepDistance = c(0,sqrt((steps$deltaX^2 + steps$deltaY^2)))\n  cumStepDistance = cumsum(stepDistance)\n\n  for (i in minIndex:maxIndex)  {\n    #Calculate distance between start and end frame.\n    startPos = trajectory[i-bufferSize,]\n    endPos = trajectory[i+bufferSize,]\n    distance = sqrt(sum((startPos-endPos)^2))\n\n    #Calculate the sum over the entire path length of the trajectory.\n    totalDistance = cumStepDistance[i+bufferSize]-cumStepDistance[i-bufferSize]\n    #Calculate the tortuosity and save it into\n    tortuosity[i] = distance/totalDistance\n  }\n  return(tortuosity)\n}\n\n###FUNCTION: Takes in a time series of centroid positions for an animal and plots a\n# square plot of the trajectory.\nplotTrajectory = function(centerData)\n{\n  maxBound = max(max(abs(centerData$CentroidX)),max(abs(centerData$CentroidY)))\n  trajectoriesPx = ggplot(centerData,aes(x=CentroidX,y=CentroidY)) + geom_point() + xlab(\"Centroid X Coordinate (px)\") + ylab(\"Centroid Y Coordinate (px)\") + coord_fixed(ratio=1,xlim = c(-maxBound,maxBound), ylim=c(-maxBound,maxBound)) + theme_bw()\n  return(trajectoriesPx)\n}\n\n\naverageByBreaks <- function(dataFrame,breaks) {\n  # This function takes a dataframe and a list of breaks, and creates averages of the entries between each break.\n  meanVals = c(rep(0,length(breaks)))\n  lastBreak = -Inf\n  for (i in 2:length(breaks)) {\n    meanVals[i-1] = mean(dataFrame[dataFrame[,1] > lastBreak & dataFrame[,1] <  breaks[i],2])\n    lastBreak = breaks[i]\n  }\n  meanVals[length(breaks)] = NA\n  return(meanVals)\n}\n\n\n##### Statistical trajectory measures #####\n##FUNCTION\n# INPUT: A series of turning angles that you wish to sequentially compare.\n# OUTPUT: A contingency table of LL, LR, RL, and RR turn sequences, as well as total L and R turns.\nanglePairContingencyTable <- function(turningAngles)\n{\n  turns <- c(rep(0,6)) ##[LL,LR,RL,RR,Lturns,Rturns]\n  for (i in 2:length(turningAngles))\n  {\n    if (turningAngles[i] > 0) #Left turn\n    {\n      turns[5] <- turns[5]+1\n      if (turningAngles[i-1] > 0) #Following a Left Turn\n      {\n        turns[1] <- turns[1]+1\n      } else  { #Following a right turn\n        turns[3] <- turns[3]+1\n      }\n    } else { #Right turn\n      turns[6] <- turns[6]+1\n      if (turningAngles[i-1] > 0) #following a left turn\n      {\n        turns[2] <- turns[2]+1\n      } else #Following a right turn\n      {\n        turns[4] <- turns[4]+1\n      }\n    }\n  }\n  Total <- length(turningAngles)-1\n  expectedLL <- (turns[5]*turns[5])/(Total^2)\n  expectedRR <- (turns[6]*turns[6])/(Total^2)\n  expectedLR <- (turns[5]*turns[6])/(Total^2)\n  expectedRL <- (turns[6]*turns[5])/(Total^2)\n  return(c(turns,expectedLL,expectedLR,expectedRL,expectedRR))\n}\n\n\nshortTimeACF = function(data,windowSize,offset,maxLag=windowSize/2)\n{\n  windowSeq = seq(1,length(data)-windowSize-1,offset)\n  acfData = matrix(0,length(windowSeq),maxLag+1)\n\n  for (i in 1:length(windowSeq))\n  {\n    start = windowSeq[i]\n    subData = data[start:(start+windowSize)]\n    subtMean = subData - mean(subData)\n    autocorr = acf(subtMean,lag.max=maxLag,plot=FALSE)\n    acfData[i,] = autocorr$acf\n  }\n  return(acfData)\n}\n\n\n##### Mean Square Displacement Functions #####\n\nmeanSquareDisplacement <- function(individualTrack,step,numRuns) {\n  ###FUNCTION###\n  #Calculates mean square displacement from a track data file.\n  #INPUT:\n  # individualTrack: a N-by-x data frame that has a time, X, and Y column in them.\n  # step: the time-step to take between recorded MSD's.\n  # numRuns: the number of runs over which to subset a track.\n\n  #OUTPUT:\n  # storeMSD: A matrix of mean square displacements for all time points chosen, from 1 to maxDelta. Also stores the frame number, standard deviation, and sample size per time point.\n\n\n  #CALCULATING MEAN-SQUARE DISPLACEMENT BETWEEN RUNS\n  #Find the longest list to set as the run length\n  print(\"Calculating minimum and maximum lengths\")\n\n  storeMSDData(individualTrack,step,numRuns)\n\n  uniqueRuns = unique(individualTrack$run)\n  for (i in uniqueRuns)\n  {\n    print(i)\n    run = as.factor(i)\n    selectedTrack <- individualTrack[individualTrack$run==run,]\n    frame <-individualTrack[individualTrack$run==run,1] #Extract all the relevant information about a particular run.\n    X <- individualTrack[individualTrack$run==run,2]\n    Y <- individualTrack[individualTrack$run==run,3]\n    for (time in 1:length(timePoints))\n    {\n      #print(paste(\"time\",time))\n      finalPos <- c(selectedTrack$X_um[selectedTrack$Time_S==(timePoints[time])],selectedTrack$Y_um[selectedTrack$Time_S==(timePoints[time])])\n      initialPos <- c(selectedTrack$X_um[selectedTrack$Time_S==0],selectedTrack$X_um[selectedTrack$Time_S==0])\n      if (!length(finalPos) == 0)\n      {\n        displace <- sum(finalPos-initialPos)\n        storeSD[time,run] <- sum(displace^2)\n      }\n    }\n  }\n  for (i in 1:length(timePoints)) #Get actual MSD data from the square displacement.\n  {\n    dataToUse <- na.omit(storeSD[i,])\n    storeMSD$time[i]<-(timePoints[i])\n    storeMSD$MSD[i] <- mean(dataToUse)\n    storeMSD$StdDev[i] <- sd(dataToUse)\n    storeMSD$numEntries[i] <- length(dataToUse)\n  }\n  storeMSD$StdDev[is.na(storeMSD$StdDev)] <- 0\n  return(storeMSD)\n}\n\nStoreMSDData = function(individualTrack,step,numRuns)\n{\n  maxLength <- max(individualTrack[,1])\n  timePoints = seq(0,maxLength,step) #The time steps ate which to record MSD\n  numEntries <- length(timePoints) #How many data points are we taking?\n  print(paste('numEntries',numEntries,''))\n  storage <- c(rep(0,numEntries))\n  storeMSD <- data.frame(time=storage,MSD=storage,StdDev=storage,numEntries=storage) #Create data frame to store entries\n  storeSD <- matrix(NA,numEntries,numRuns)\n}\n\n\n\n###FUNCTION: Calculates the mean square displacement within an inidividual trajectory.It does so by dividing the trajectory into numRuns runs and calculating the MSD at the time points step distance apart.\n#INPUT:\n# individualTrack:\n# step:\n# numRuns:\n#OUTPUT:\nMSDWithinRun = function(individualTrack,step,numRuns)\n{\n  print(\"Calculating MSD by sub-sampling run.\")\n  runLength <- floor(max(individualTrack[,1])/numRuns) #The length of each track.\n\n  startFrames <- seq(0,max(individualTrack[,1]),runLength) #The sequence of starting times when sub-dividing track into multiple independent runs.\n  startFrames = startFrames[1:numRuns]\n\n  timePoints = seq(0,runLength,step) #The series of dT times at which to measure square displacement within a run.\n  numEntries <- length(timePoints) #The total sample size of runs created by the following track separation.\n  storeSD <- matrix(0,numEntries,numRuns) #Storage for square displacement in each individual run.\n  storage <- c(rep(0,numEntries))\n  storeMSD <- data.frame(time=storage,MSD=storage,StdDev=storage,numEntries=storage) #Create data frame to store entries\n\n  measureTimes = sapply(startFrames,function(data) newData=data+timePoints) %>% as.matrix()+1\n  cxs = (individualTrack$CentroidX[measureTimes]) %>% matrix(nrow=numEntries,ncol=numRuns) %>% t()\n  cxs2 = (cxs - individualTrack$CentroidX[measureTimes[1,]])^2\n  cys = (individualTrack$CentroidY[measureTimes]) %>% matrix(nrow=numEntries,ncol=numRuns) %>% t()\n  cys2 = (cys - individualTrack$CentroidY[measureTimes[1,]])^2\n\n  SDStore = cxs2+cys2\n  MSD = apply(X = SDStore,MARGIN = 2,mean)\n\n  #print(paste(\"recordFrame\",recordFrame,\"Time_s\",individualTrack$Time_S))\n  storeMSD$time<-timePoints\n  storeMSD$MSD <- apply(X = SDStore,MARGIN = 2,mean)\n  storeMSD$StdDev <- apply(X = SDStore,MARGIN = 2,sd)\n  storeMSD$numEntries <- numRuns\n  return(storeMSD)\n}\n",
    "created" : 1491514866270.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3345678634",
    "id" : "2358EFCB",
    "lastKnownWriteTime" : 1493846843,
    "last_content_update" : 1493846843,
    "path" : "D:/Mircea/ScriptLibraries/R/mover/R/MovementAnalysisFunctions.R",
    "project_path" : "R/MovementAnalysisFunctions.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}